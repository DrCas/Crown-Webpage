CROWN GRAPHICS ‚Äî CONSOLIDATED MASTER DOCUMENTATION
===============================================

SECTION A ‚Äî MASTER PROJECT CONTEXT (Updated)
--------------------------------------------

Crown Graphics ‚Äî MASTER PROJECT CONTEXT

(Authoritative / Replaces all prior chats)

1. Project Overview

Crown Graphics website is currently a static HTML / CSS / JS site.

The site is a visual and UX prototype of the production CrownGFX site.

Backend functionality (orders, email, admin, payments) is intentionally separated and introduced incrementally.

Raspberry Pi is used for development/testing, but production hosting will be web-based.

GitHub (public) is the single source of truth for code.

2. Tech Stack (Current & Planned)
Frontend (Live Today)

HTML5

CSS3 (single unified styles.css)

Vanilla JavaScript

Google Fonts (Poppins)

Google Maps embed

Backend (Designed / Partially Built)

Python Flask

SQLite (Pi-friendly, intentional)

Cloudflare Tunnel (admin access)

Dummy email system ‚Üí real provider later

Stripe planned for payments

3. Global Design & UX Rules (Locked)
Branding

Color palette: Black / White / Gold accent

Font: Poppins (global)

Images: WebP preferred for all photography

Logos/UI assets may remain PNG/SVG

Header & Navigation

Sticky black header on all pages

Logo is image-based (not text)

Consistent navigation across all pages

Mobile nav is stacked (no hamburger yet)

Background Handling

Same background image applied to both html and body

Mobile uses background-attachment: scroll

Prevents white flashes and black gaps

4. Glass / Panel System (Very Important ‚Äì Finalized)
Single Source of Truth

.glass is the only class that defines:

background color

shadow

blur / surface effect

No other class may redefine these properties.

Glass Style (Final)

Light neutral grey surface

Subtle blur (or none if unsupported)

Rounded corners

Soft elevation shadow

No heavy blur, no glow, no dark tint

Usage Rules

Apply .glass directly to the visual panel

Never nest glass inside glass

Layout/helper classes must NOT style panels

‚úÖ Correct:

<section class="container readable glass">


‚ùå Incorrect:

.readable.glass { background: ... }

5. Pages & Features (Consolidated)
Home (index.html)

Hero section with:

Background image

Logo

Headline

CTA ‚Üí Contact

Services grid:

Vehicle Wraps

Signs & Banners

Custom Decals

Each service requires a matching image asset

About (about.html)

Single centered glass panel

Large readable typography

Banner header with gradient overlay

No additional decorative panels

Contact (contact.html)

Desktop: two-column layout

Mobile: stacked

Independent glass panels:

Intro text

Contact form

Map + business info

Google Maps embed:

13766 Redwood St, Chino, CA 91710

Contact form:

mailto: only (temporary, unreliable)

Portfolio (portfolio.html)

Final architecture (conflicts resolved):

Top: Autoplay-only slideshow (non-interactive)

Bottom: Thumbnail gallery

Glass applies ONLY to slideshow

Gallery has NO glass (performance decision)

Slideshow

Autoplay

Fade transitions

Image counter

No clicking / navigation

Uses sequential filenames:

images/Collection/Slides/slide-1.webp
slide-2.webp
...

Gallery

Responsive CSS grid

Lazy loading + IntersectionObserver

Clicking thumbnail opens lightbox

Lightbox

Full-screen modal

ESC / backdrop / close button supported

‚ö†Ô∏è Gallery-grid-only or full-gallery-only designs were explicitly abandoned due to performance issues.

Quick Order (quick-order.html)
Order Flows

Quick Print (print-ready)

Large Projects / Wraps (proof-required)

Pricing Rules (Locked)

Minimum charge: $50

Sqft always rounded up

Rotation allowed for material efficiency

Printed Items

$23 / sqft

54" roll

Extra 12" ONLY if print-and-cut

Die-Cut (1 color)

$18 / sqft

30" roll

No extra material

Large Projects

Fixed $250 non-refundable deposit

Configurable later

Front-end only for now

6. Image Strategy (Final)

All photographic images converted to WebP

Originals preserved separately for print

CSS + inline background paths updated to .webp

Portfolio JS supports WebP natively

Thumbnails recommended for performance

7. Admin Portal (Internal System)
Architecture

Flask + SQLite (crown_portal.db)

Shared backend with customer orders

Hosted internally via Cloudflare Tunnel

User Roles

Admin

Staff

Admins:

Manage users

Reset passwords

View audit logs

Safety rules:

Admin cannot delete themselves

Cannot delete last admin

Job System

Fields

Customer name

Business name

Phone

Email

Job title

Summary

Notes

Quote

Date Received (manual)

Date Created (auto)

PO Format

MMDDYY-##

Based on Date Received

Resets daily

Safe overflow beyond 99

Progress Stages

Received

Design

Proof

Production

Install / Pickup

Completed

Visual segmented progress bar

Completed jobs auto-archive

Audit Logs (Admin Only)

Timestamp

User

Action

Field diffs

Stage changes

8. Customer Orders ‚Üí Admin Portal (Confirmed Flow)

Customer order submission:

Creates admin job automatically

Sends email notification

New jobs flagged with NEW / !

Shared database between customer + admin systems

Dummy Mode (Required First)

Emails printed to console

Emails stored in email_outbox table

No real payments or SMTP

9. Constraints (Hard Limits)

Static HTML alone cannot:

send reliable emails

store orders

handle uploads

SQLite has no auto migrations

Gallery blur must remain limited

Mailto forms are temporary only

10. Unresolved / Next Decisions

Hosting strategy:

static + /order backend

OR full Flask migration

Payment provider finalization (Stripe planned)

Email provider selection

File upload storage strategy

Admin UI:

New-order indicator

Mark reviewed

Optional future:

Customer login

Proof approval portal

Reporting / exports

11. Current State

Website design is client-ready

Mobile & desktop stable

Admin portal architecture locked

Order ‚Üí admin ‚Üí email flow approved

Ready for incremental implementation

12. Order Intake System Upgrade (Feb 2026 ‚Äì Implemented)

Website Side (Crown Static Site)

Structured Order Forms Added

Quick Print Order:
- Customer information fields
- Requested item type
- Needed‚Äëby date
- Order summary
- Requested items table (qty / description / material / notes)
- File uploads
- Terms acceptance checkbox

Large Project / Wrap Intake:
- Customer information
- Project type and service needed
- Design status
- Install location
- Vehicle details
- Scope / measurements
- Optional item table
- File uploads
- Terms acceptance checkbox

These forms are structured for real production intake rather than simple contact-form emails.


Terms Page

A dedicated terms.html page now exists containing:
- Estimate disclaimers
- Pricing subject‚Äëto‚Äëchange language
- Deposit policy
- Warranty terms:
  - 1 year on horizontal surfaces
  - 2 years on vertical surfaces
- Installation conditions
- Artwork approval terms
- Privacy statement

Order forms link directly to this page.


Backend Order Intake System (Admin Portal)

New modules added inside Admin-Portal:
- orders_api.py
- pdf_utils.py
- email_utils.py

New Endpoint:
POST /api/orders

Accepts:
- FormData (including file uploads)
- order_type (quick or large)
- items_json (table rows)
- All customer and project fields


API Behavior (End-to-End Design)

When fully wired, the system will:
1. Create a new database entry in the Admin Portal
2. Store submission JSON
3. Store uploaded file paths
4. Generate a PDF using ReportLab
5. Send:
   - Internal notification email
   - Customer confirmation email
   - PDF attached to emails

Email delivery is SMTP‚Äëconfigurable (temporary Gmail or future business mail).


nginx Routing Layer

Routing rule added:

location /api/ {
    proxy_pass http://127.0.0.1:5000;
}

Resulting request flow:

Static site (dev.drcastiel.com)
‚Üí /api/orders
‚Üí nginx
‚Üí gunicorn (Flask)
‚Üí SQLite database
‚Üí PDF generation
‚Üí Email system

This avoids CORS issues and keeps a clean architecture.


Service Architecture (Current Design)

Customer
  ‚Üì
Static Site (nginx)
  ‚Üì
/api/orders
  ‚Üì
nginx proxy
  ‚Üì
gunicorn (crown-admin.service)
  ‚Üì
Flask application
  ‚Üì
SQLite (crown_portal.db)
  ‚Üì
PDF generation
  ‚Üì
Email system (SMTP-ready)


Current Incomplete Items

The following items are intentionally pending:

- Blueprint registration in app.py
- Database column additions if required for JSON storage
- SMTP credentials configuration
- Frontend fetch() submission wiring
- Production email testing


Current Status

- Backend service running
- nginx routing configured
- Repository up to date
- API files present on Raspberry Pi
- Infrastructure in place for full intake workflow

The system has evolved from a static marketing site into a structured production intake pipeline that feeds the Admin Portal.



SECTION B ‚Äî WEB / INFRASTRUCTURE / ORDER SYSTEM DURABLE STATE
-------------------------------------------------------------

Crown-Webpage ‚Äî Durable Decisions & Current State
Repository & Version Control Decisions

GitHub repository: DrCas/Crown-Webpage

Branch standardized to main

Repository structure retained:

Crown/ ‚Üí static website

Admin-Portal/ ‚Üí Flask-based admin system

Root .gitignore implemented to exclude:

*.db (database files)

Crown/images/

Crown/images webp/

Python cache / virtual env folders

Database file (crown_portal.db) is intentionally excluded from version control.

Images are intentionally not stored in GitHub.

Image Handling Strategy (Durable Deployment Decision)
Storage Strategy

Images will be stored directly on the Raspberry Pi, not in GitHub.

Folder structure on Pi will mirror expected HTML paths (e.g., Crown/images/).

Images are treated as deployment assets, not versioned code.

Deployment Workflow

Code updates:

PC ‚Üí git push

Pi ‚Üí git pull

Image updates (only when needed):

Manual sync to Pi (rsync / SFTP / similar)

Once images are on the Pi and file names remain unchanged, they do not require further maintenance.

Website (Crown/) ‚Äî Built Features
Pages Implemented

index.html

about.html

contact.html

portfolio.html

quick-order.html

Design & UX

Sticky header navigation

Glass UI components (frosted blur effect)

Hero banner with overlay gradient

Responsive layout for mobile

Background image handling optimized for desktop/mobile

Portfolio lightbox viewer

Thumbnail preview strip

Autoplay slider

Performance Improvements

Images converted to WebP (local use)

Portfolio slider loads images dynamically

Thumbnails separate from main display

Background scroll performance optimized for mobile

Quick Order System (Front-End)
Dual Intake Types

Quick Print Items

Size input (width/height in inches)

Quantity

Product type selection

Artwork upload

Client-side square footage calculator

Minimum $50 enforced

Pricing tiers for die-cut vs printed

54‚Äù and 30‚Äù roll width logic

Automatic rotation optimization

Large Projects / Wraps

Project type dropdown

Vehicle details

File uploads

Deposit requirement displayed ($250)

Admin Portal (Flask)
Core Capabilities

User authentication

Role system

Job creation and viewing

Dashboard view

Password reset capability

User management pages

Template-based layout structure

Static CSS for admin styling

Database

SQLite-based

Stored locally (not versioned)

Excluded from Git

Structural Decisions

Website and Admin Portal remain in the same repo for now.

Images excluded from version control permanently.

Repo kept code-only for long-term cleanliness.

Branch tracking configured properly with upstream origin/main.

Legacy root-level website structure removed; only Crown/ + Admin-Portal/ retained.

Constraints

GitHub 100MB per-file hard limit.

Images are binary and unsuitable for diff-based version control.

SQLite database should not be versioned.

Raspberry Pi will serve both static site and admin backend.

Unresolved / Future Items
Deployment Architecture

Finalize exact Pi directory structure for production.

Decide whether to:

Keep unified repo long-term

Split into separate repos (Site vs Admin)

Image Strategy (Future)

Consider CDN or Cloudflare caching.

Possibly implement automated rsync deployment script.

Order System Enhancements

Backend email notification integration.

Automatic admin job creation from customer submissions.

Terms & warranty legal copy finalization.

Server-side pricing validation (currently client-side).

Scaling Considerations

Potential migration from SQLite if concurrency increases.

NAS or expanded storage strategy for media-heavy workflows.

Current State Summary

Repository clean and synchronized.

No image assets stored in GitHub.

Local folder structure clean.

Merge conflicts resolved.

Deployment model defined (code via Git, images via manual sync).

Website and admin portal both functional in structure.

Project is now in a stable, version-controlled, production-ready structural state.

Durable Decisions

The printed Estimate / Work Order will be generated from an HTML template (landscape 8.5x11) rather than filling coordinates directly onto the existing PDF.

The HTML template is structured to match the provided estimate sheet layout, including:

Header with logo placeholders and Estimate #

Three-panel row (Customer Info / Vehicle Info / Dates)

Full-width Summary section

Full-width Line Items table

Bottom row (Office Info / Locations / Totals)

Signature section

The template is designed specifically for print output, not interactive browser use.

Slight margins and spacing are intentionally preserved to ensure print-safe layout across printers.

The same template will be used for:

Admin-created jobs

Customer-submitted orders

PDF email attachments

Print-from-admin functionality

Features Built

Multiple iterations of an Estimate HTML template:

Bubble-style and underline-style field designs.

Layout adjusted to closely match the uploaded estimate sheet.

Landscape Letter sizing (11in x 8.5in).

Print-optimized CSS with hidden print button.

Table structure supporting multiple line items.

Template structured to support dynamic population using backend variables (e.g., {{ customer_name }}).

Layout designed to support:

Static header content

Dynamic estimate number

Customer and vehicle fields

Tracking and approval dates

Line-item loop rendering

Totals breakdown

Signature line

Constraints Identified

Final document must fit cleanly on 8.5 x 11 landscape without clipping.

Printer margins cannot be fully eliminated; layout must remain within safe print bounds.

HTML template will not be manually edited in production; it will be auto-populated from backend data.

Layout must remain structurally stable to support consistent PDF generation.

Must support both:

Admin portal population

Customer order intake population

Planned Data Population Method

Template will use placeholder variables (e.g., {{ customer_name }}).

Backend will pass structured job data to the template renderer.

Line items will be populated via loop iteration.

Same template will be used to:

Render admin print view

Generate PDF

Attach PDF to email notifications

Unresolved / Deferred Items

Backend implementation for:

Template rendering

PDF generation

Email attachment integration

Final refinement of exact spacing to perfectly match original PDF aesthetics.

Locking which fields are admin-only vs customer-generated.

Deciding whether to preserve credit card fields in printed estimate.

Final confirmation of total number of line-item rows per page.

Full integration into Admin Portal ‚ÄúPrint Form‚Äù button.

Customer order ‚Üí auto-create job ‚Üí auto-generate PDF ‚Üí email attachment pipeline.

This reflects only durable structural decisions and remaining implementation tasks from this discussion.

‚úÖ Durable Decisions
Domain & Infrastructure

Domain purchased: drcastiel.com

Cloudflare added as DNS provider

Nameservers updated and domain is Active

Cloudflare Free plan

Bot blocking enabled (acceptable for dev environment)

Subdomain Architecture

dev.drcastiel.com ‚Üí Crown static development site

admin.drcastiel.com ‚Üí Admin portal (planned, port 5000)

Domain will serve as long-term infrastructure namespace for multiple projects

Hosting Strategy

Self-hosted on Raspberry Pi

nginx serves static Crown site from:

/mnt/ssd/crowngfx/Crown-Webpage/Crown


No port forwarding (Cloudflare Tunnel used instead)

Home IP remains hidden

Cloudflare Tunnel Setup

Named tunnel created: drcastiel

Tunnel UUID:

e21ed65f-87d9-403f-8115-5cc304c56305


DNS routes created automatically:

dev.drcastiel.com

admin.drcastiel.com

System-wide config used:

/etc/cloudflared/config.yml


cloudflared installed via .deb package

cloudflared running as systemd service

Tunnel Ingress Routing
dev.drcastiel.com   ‚Üí http://localhost:80
admin.drcastiel.com ‚Üí http://localhost:5000
fallback            ‚Üí 404

‚úÖ Features Built

Static Crown site publicly accessible over HTTPS

Automatic SSL via Cloudflare

Subdomain-based routing

Persistent tunnel (auto-start service)

Production-style reverse tunnel architecture

No dependency on temporary trycloudflare URLs

‚úÖ Constraints / Rules Established

Subdomains require ownership of root domain

Unlimited subdomains allowed (no cost increase)

DNS record count does not affect domain cost

Domain cost is flat yearly renewal (~$10.46/year)

Domain expiration does not affect hosted code or GitHub repositories

Admin portal requires service running on port 5000

Static nginx content confirmed working on port 80

‚ö†Ô∏è Unresolved / Pending Items

Admin portal service not yet running

admin.drcastiel.com will error until Flask/Gunicorn runs on port 5000

Confirm final validation of:

systemctl status cloudflared.service

tunnel connection health

Future infrastructure expansion planning:

Additional subdomains (API, lab, media, etc.)

Security hardening (Cloudflare Access for admin)

Deployment automation (Git auto-pull)

üß† Current Architecture Snapshot

Internet
‚Üí Cloudflare DNS
‚Üí Cloudflare Tunnel (drcastiel)
‚Üí Raspberry Pi
‚Üí nginx (port 80 static site)
‚Üí Future Flask admin (port 5000)

This reflects the stable infrastructure state at the end of this session

Crown / drcastiel Infrastructure ‚Äì Durable State
1Ô∏è‚É£ Cloudflare Tunnel Architecture
Established Structure

Single named tunnel: drcastiel

cloudflared running as a persistent systemd service

Config located at:

/etc/cloudflared/config.yml

Tunnel Routing

dev.drcastiel.com ‚Üí nginx (port 80)

admin.drcastiel.com ‚Üí nginx (port 80)

nginx routes internally by hostname

Cloudflare is not directly routing to Gunicorn.

2Ô∏è‚É£ Nginx Configuration
Active Sites

Located in:

/etc/nginx/sites-available/


Enabled via:

/etc/nginx/sites-enabled/

Routing Logic

dev.drcastiel.com

Serves static Crown site

Root:

/mnt/ssd/crowngfx/Crown-Webpage/Crown


admin.drcastiel.com

Reverse proxies to Gunicorn

Proxies to:

127.0.0.1:5000


Default nginx catch-all removed.

3Ô∏è‚É£ Admin Portal Runtime
Stack

Flask app

Gunicorn

systemd service: crown-admin

Gunicorn Binding
127.0.0.1:5000

Service Persistence

crown-admin enabled

cloudflared enabled

Both survive reboot

4Ô∏è‚É£ File Ownership Standardization

Project ownership normalized to:

castiel:www-data


Applied to:

/mnt/ssd/crowngfx/Crown-Webpage


Prevents future permission conflicts between:

Git operations

Nginx (www-data)

Gunicorn

Manual edits

5Ô∏è‚É£ Image Performance Optimization
Existing State

Original images converted to WebP

Largest files approx. 1‚Äì1.5MB

Portfolio slideshow contained 44 full-size images

Thumbnail strip was loading full-size images

Structural Change Implemented

Created:

Crown/images/Collection/Slides/thumbs/


Generated 400px-wide thumbnails for:

slide-*.webp

Pending Integration

JavaScript still needs to be updated so:

Thumbnail strip loads from /thumbs/

Main slide + lightbox load full-size images

This is the primary unresolved front-end task.

6Ô∏è‚É£ Confirmed Bottleneck Findings

Not Cloudflare limitation

Not Raspberry Pi hardware limitation

Not tunnel limitation

Primary performance issue caused by:

Loading too many full-size images simultaneously

Browser request queueing

Lack of true thumbnails

7Ô∏è‚É£ Future Project: Personal Landing Dashboard
Decision Made

A custom landing/dashboard page will be built for:

www.drcastiel.com


Purpose:

Central project hub

Server health overview

Links to dev/admin/projects

Planned Features

Uptime

cloudflared status

gunicorn status

CPU temp

Memory usage

Disk usage

Quick links

Security Direction

Likely private / protected (not fully public).
Potential methods:

Cloudflare Access

SSO

Separate private subdomain

8Ô∏è‚É£ Security Position

Current admin security model:

Publicly reachable

Protected by Flask authentication

Future consideration:

SSO (Google OAuth or Cloudflare Access)

Identity-based access rather than IP restriction

IP-only restriction not selected as preferred strategy.

Current Unresolved Items

Update slideshow JS to use generated thumbnail files.

Decide final architecture for personal dashboard domain (www vs private subdomain).

Implement dashboard backend status endpoint when project begins.

Infrastructure Status

‚úî Cloudflare tunnel operational
‚úî Nginx routing by hostname
‚úî Gunicorn running and persistent
‚úî Admin + Dev separated cleanly
‚úî Ownership normalized
‚úî Thumbnail files generated

System is stable and production-structured.

Crown Website ‚Äì Portfolio Optimization Update
Durable Decisions
1Ô∏è‚É£ Thumbnail Performance Architecture

Full-size portfolio images remain in:
images/Collection/Slides/

Optimized thumbnails stored in:
images/Collection/Thumbs/

Thumbnail files match full-size filenames exactly.

Thumbnails generated using ImageMagick:

Resize width to 400px (-resize 400x)

Quality 75

Slider loads:

Main image ‚Üí from Slides

Thumbnails ‚Üí from Thumbs

Thumbnail mapping handled in JS via:

const THUMB_FOLDER = "images/Collection/Thumbs/";
const fileName = fullPath.split("/").pop();
im.src = THUMB_FOLDER + fileName;

2Ô∏è‚É£ Lightbox Viewport Constraint Fix

Large/tall images are now constrained to viewport height.

Final behavior:

Modal is centered via flexbox.

Modal capped at max-height: 90vh

Image capped at max-height: 72vh

Image uses object-fit: contain

No fixed height values

No top margin pushing modal down

This ensures:

No overflow

No scrollbars

Consistent padding around images

Tall posters remain inside monitor bounds

3Ô∏è‚É£ Deployment Model Clarified

Static files served via nginx.

No server restart required for HTML/CSS/JS updates.

Browser hard refresh required to bypass caching.

Optional nginx restart:

sudo systemctl restart nginx


Cloudflare cache may require purge if enabled.

4Ô∏è‚É£ Git Workflow Clarified

All production edits should originate from PC ‚Üí push to GitHub.

Pi should only:

git pull


If repo mismatch occurs:

git fetch origin
git reset --hard origin/main


Avoid editing files directly on Pi to prevent divergence.

Features Built

Thumbnail generation workflow using ImageMagick (Windows + Pi compatible).

Proper thumbnail-folder loading in slider.

Optimized gallery performance (no full-size images in thumbnail strip).

Lightbox image scaling that respects viewport height.

Confirmed production-ready deployment workflow.

Constraints Identified

Thumbnail filenames must exactly match slide filenames.

Linux (Pi) is case-sensitive.

Inline JS in portfolio.html can cause environment mismatch if not committed.

Cloudflare/browser caching can mask updates.

Static site does not require reboot or service restart.

Unresolved / Optional Improvements

Consider moving inline portfolio script to external portfolio.js for cleaner version control.

Potential future improvements:

Lazy-load next slide image

Swipe support for mobile

Lightbox arrow navigation

Progressive blur placeholders

Fade transitions

Net Result

Portfolio now:

Loads significantly faster.

Does not pull large images for thumbnails.

Keeps tall images inside viewport.

Has a clean Git ‚Üí Pi deployment flow.

Durable Decisions
1Ô∏è‚É£ Image Hosting Strategy

Images (Slides + Thumbnails) are not stored in GitHub to avoid repository size limits.

Images are manually deployed to the Pi under:

/mnt/ssd/crowngfx/Crown-Webpage/Crown/images/Collection/


Deployment workflow:

Git handles HTML/CSS/JS only.

Images must be manually uploaded or synced to the Pi.

2Ô∏è‚É£ Folder Structure Standardized

Final required structure:

images/
  Collection/
    Slides/     ‚Üê full-resolution images
    Thumbs/     ‚Üê optimized thumbnail images


Folder names are case-sensitive (Linux requirement).

JS expects Thumbs (capital T).

3Ô∏è‚É£ Portfolio Architecture

Portfolio now uses:

portfolio.js (external file, not inline script)

Dynamic gallery generation

Lazy loading

Thumbnail ‚Üí Full image click behavior

Configuration inside portfolio.js:

const FOLDER = "images/Collection/Slides/";
const THUMB_FOLDER = "images/Collection/Thumbs/";


Design behavior:

Thumbnails load from Thumbs/

Lightbox + slider load full images from Slides/

Fallback logic exists if thumbnails fail

4Ô∏è‚É£ Lazy Loading Implementation

Thumbnails are loaded via IntersectionObserver

Images use data-src until visible

Improves performance for large galleries

5Ô∏è‚É£ nginx Configuration (Confirmed Stable)

dev.drcastiel.com server block:

root /mnt/ssd/crowngfx/Crown-Webpage/Crown;
location / {
    try_files $uri $uri/ =404;
}


Static files are served directly.

Verified 200 responses for thumbnails and slides.

Cloudflare tunnel routing is correct.

6Ô∏è‚É£ Dev vs Production Behavior

Browser caching caused false-negative behavior during testing.

Private window confirmed correct deployment.

Clearing browser cache resolved stale asset issue.

Durable takeaway:

Dev environment is sensitive to browser cache when folder structures change.

Features Built
‚úî Externalized Portfolio JavaScript

Removed inline JS from portfolio.html

Uses standalone portfolio.js

‚úî Thumbnail System

Separate optimized thumbnail directory

Gallery grid rendered dynamically

Lazy loaded thumbnails

‚úî Full-Resolution Slider + Lightbox

Slide navigation

Autoplay support

Click-to-open modal view

‚úî Cloudflare Tunnel Deployment

dev.drcastiel.com ‚Üí nginx static site

admin.drcastiel.com ‚Üí Flask app (proxy to port 5000)

Constraints

Images are not version-controlled in Git.

Manual image sync required for new assets.

Linux filesystem is case-sensitive.

Browser caching can mask deployment changes.

Thumbnail folder name must match JS exactly (Thumbs).

Unresolved / Future Improvements
1Ô∏è‚É£ Dev Cache Strategy

Currently:

Browser caching can interfere with testing.

Possible improvement:

Disable caching for dev.drcastiel.com in nginx.

Add version query strings to JS/CSS automatically.

2Ô∏è‚É£ Image Deployment Workflow

Since images aren‚Äôt in Git:

Consider automated rsync workflow from PC ‚Üí Pi.

Or structured ‚Äúimage deploy checklist‚Äù in project docs.

3Ô∏è‚É£ Fallback Logic Review

Current logic:

img.dataset.src = thumbImages[i] || url;


Works correctly.

Might consider logging fallback behavior during development for easier debugging.

Current Stable State

‚úî Slides and Thumbs folder correctly structured
‚úî Case sensitivity aligned
‚úî JS file confirmed correct
‚úî nginx serving correct root
‚úî Cloudflare routing verified
‚úî Thumbnail loading from /Thumbs/
‚úî Full images loading from /Slides/
‚úî Portfolio functioning as designed

Durable Decisions
Architecture

Static Crown website remains served by nginx.

Admin Portal remains served by gunicorn via crown-admin.service on 127.0.0.1:5000.

Website ‚Üí Admin Portal communication occurs via:

POST /api/orders


nginx routes /api/* from dev.drcastiel.com to gunicorn using:

location /api/ ‚Üí proxy_pass http://127.0.0.1:5000

Order Intake Strategy

Website forms do not calculate or display pricing.

All pricing logic remains backend-side.

Orders are submitted via fetch(FormData) to Flask.

Submissions include:

Customer information

Order type (quick / large)

Structured items table (JSON)

File uploads

All submission data is stored as JSON (TEXT columns for SQLite).

Email Strategy

Email sending will use SMTP.

Temporary testing can use Gmail with App Password.

Email sending should be toggleable (e.g., ENABLE_EMAIL flag).

Both internal notification and customer confirmation emails will include a generated PDF.

Features Built
1Ô∏è‚É£ Website
Quick Order Form

Customer information fields

Requested item type selector

Needed-by date

Summary field

Dynamic item table (qty / description / material / notes)

File uploads

Terms acceptance checkbox

Submission via JavaScript fetch() to /api/orders

Large Project Intake Form

Expanded intake structure:

Project type

Service needed (print/install/design)

Design status

Install location

Vehicle details

Scope description

Optional item table

File uploads

Terms checkbox

Submission via same API endpoint

Terms Page (terms.html)

Includes:

Estimate disclaimer (pricing subject to change)

Deposit policy

Production/scheduling language

Artwork approval terms

Installation conditions

Warranty:

1 year horizontal surfaces

2 years vertical surfaces

Privacy statement

2Ô∏è‚É£ Backend (Admin Portal)
New Files Added

Inside Admin-Portal/ root:

orders_api.py

pdf_utils.py

email_utils.py

API Endpoint
POST /api/orders


Responsibilities:

Validate submission

Accept multipart form data

Store order data in DB

Save uploaded files

Generate PDF using ReportLab

Send emails (internal + customer)

PDF Generation

Implemented using ReportLab.

Generated dynamically per order.

Attached to outgoing emails.

3Ô∏è‚É£ Infrastructure
nginx Configuration

Added /api/ proxy block to dev.drcastiel.com.

Admin Portal already proxied fully under admin.drcastiel.com.

Verified gunicorn running via crown-admin.service.

Service Architecture

Final flow:

Customer
   ‚Üì
dev.drcastiel.com (nginx static)
   ‚Üì
/api/orders
   ‚Üì
nginx proxy
   ‚Üì
gunicorn (127.0.0.1:5000)
   ‚Üì
Flask app
   ‚Üì
SQLite (crown_portal.db)
   ‚Üì
PDF + Email

Constraints

Database is SQLite (crown_portal.db).

No JSON column type available ‚Üí JSON stored as TEXT.

Admin Portal is a single-file Flask app (app.py).

Gunicorn bound to 127.0.0.1:5000.

Email not yet configured (SMTP credentials not set).

Blueprint must be explicitly registered in app.py.

Unresolved Items
Backend Wiring

Confirm orders_api blueprint is imported and registered in app.py.

Confirm /api/orders route returns non-404 response.

Ensure JSON storage fields exist in Job/Order model (if needed).

Database Integration

Decide whether:

Integrate directly into existing Job model, or

Use separate Order model.

If integrating:

Add submission_json and uploaded_files_json TEXT columns.

Ensure orders appear in existing Admin dashboard.

Frontend Finalization

Confirm quick-order.html uses final fetch submission logic.

Confirm form resets and row clearing after successful submission.

Email Configuration

Configure SMTP environment variables.

Decide on:

Temporary Gmail App Password

Future domain-based mail service

Enable ENABLE_EMAIL flag when ready.

Testing

Validate:

API reachable via nginx (dev.drcastiel.com/api/orders)

DB record creation

PDF generation

Email dispatch

File upload storage

Current State Snapshot

Static site working.

Admin Portal running.

nginx proxy block configured.

Backend API files present.

Repository up to date on Pi.

API not yet confirmed active (blueprint registration pending).

Email not yet configured.

End-to-end submission not yet validated.

Crown Web + Admin Portal ‚Äî Durable Project State
Infrastructure Decisions

Hosting: Raspberry Pi running:

Nginx (reverse proxy)

Gunicorn (Flask app server)

systemd service: crown-admin

Routing: Cloudflare Tunnel serving dev.drcastiel.com

Application Bind: Gunicorn bound to 127.0.0.1:5000

File Upload Storage: uploads/orders

Database: SQLite (crown_portal.db) for admin/auth

Admin Portal (Flask)
Authentication

User table: user

Columns: id, username, password_hash, role

Passwords hashed using:

generate_password_hash

check_password_hash

Admin recovery method established via Python shell reset script.

No plain-text passwords stored.

Order Intake API
Endpoint
POST /api/orders

Input

multipart/form-data

Fields:

order_type (quick | large)

name

email

phone (optional)

company (optional)

items_json (JSON string)

files[] (optional uploads)

Behavior

Validates required fields

Saves uploaded files securely

Generates timestamp-based order_id

Parses items_json

Builds in-memory order_data dict (no DB persistence yet)

Generates PDF summary

Sends:

Internal notification email

Customer confirmation email

Returns structured JSON:

{
  "ok": true,
  "order_id": "...",
  "email_sent": true|false,
  "email_error": null|string
}


Returns HTTP 201 Created

Email failures do not crash the endpoint

PDF System

Implemented with ReportLab

Letter format

Includes:

Order ID

Order type

Customer info

Items table

Attached automatically to both internal and customer emails

Email System
Configuration

SMTP credentials stored in:

/etc/crown-admin.env


Loaded via:

EnvironmentFile=/etc/crown-admin.env


File secured with:

chmod 600

Required Variables

SMTP_HOST

SMTP_PORT

SMTP_USE_TLS

SMTP_USE_SSL

SMTP_USER

SMTP_PASS (Google App Password)

FROM_EMAIL

INTERNAL_NOTIFY_EMAIL

Verified

Email sending confirmed functional

Internal + customer emails delivered

PDF attachment confirmed

Secure credential handling (no secrets in repo)

Constraints

Orders are not yet persisted to database (in-memory only).

No admin UI yet for viewing intake orders.

No pricing logic integrated into intake.

No automated job creation from intake.

Gmail SMTP used; requires Google App Password.

Upload size limits governed by Nginx (not yet tuned for large production files).

Current System Status

Public site active.

Admin portal operational.

Intake API functional locally and via Cloudflare.

File uploads verified.

PDF generation verified.

Email notifications verified.

Secure environment configuration implemented.

Admin login functional and recoverable.

Unresolved / Future Enhancements

Persist orders to database.

Build admin dashboard for viewing intake.

Add order status tracking.

Integrate pricing engine for quick orders.

Automate conversion from intake ‚Üí job record.

Tune Nginx upload limits for large production files.

Wire public Quick Order form directly to /api/orders.

Infrastructure Strategy Decisions
1Ô∏è‚É£ Self-Hosting Model

Website and Admin Portal are self-hosted on Raspberry Pi.

nginx used as reverse proxy.

Flask app runs on internal port 5000.

Public traffic routed through Cloudflare Tunnel.

Separation between:

Public static site

Backend API/Admin system

This architecture mirrors standard production reverse-proxy setups.

2Ô∏è‚É£ Reverse Proxy Architecture

Durable pattern established:

Internet
‚Üì
Cloudflare Tunnel
‚Üì
nginx (80/443)
‚Üì
Flask backend (5000)


This is the chosen architectural baseline moving forward.

3Ô∏è‚É£ Hosting Philosophy Decision

Confirmed:

Self-hosting provides full control.

Requires responsibility for:

Uptime

Security

Backups

Power reliability

Hardware health

Future migration to VPS or managed hosting remains viable without architectural redesign.

Raspberry Pi Hosting Capacity
Current Assessment

Raspberry Pi is suitable for:

Static website hosting

Flask backend/API

Admin portal

Low-to-moderate traffic

Multiple subdomains (subdomains ‚â† load)

Small automation services

Limitations:

High concurrent traffic

Heavy CPU tasks

Large file processing

Heavy game servers

Mission-critical uptime

Pi is acceptable for early-stage production but not ideal for long-term high-load scaling.

Power Draw Conclusions
Raspberry Pi

3‚Äì8 watts typical draw

~$3‚Äì7/year in electricity

Extremely efficient for 24/7 operation

NAS Power Profiles
Prebuilt NAS (Synology/QNAP class)

15‚Äì25W idle

25‚Äì45W active

~$25‚Äì60/year

Optimized for:

Storage

Redundancy

24/7 reliability

Not optimized for:

Heavy compute

Game servers

High transcoding workloads

Custom Low-Power Server Build

20‚Äì35W idle

40‚Äì80W typical load

90‚Äì120W heavy load

~$40‚Äì120/year

Supports:

Plex transcoding

Game servers

Docker stacks

Multiple services

Website hosting

Virtual machines

Plex Hosting Requirements
Direct Play

Low CPU demand

NAS sufficient

Transcoding

High CPU demand

Requires stronger processor

Most consumer NAS units limited here

Decision implication:
Storage-focused NAS ‚â† compute-focused server.

Infrastructure Growth Path (Durable Plan)

Recommended long-term evolution:

Phase 1 ‚Äî Pi

Learning

Light production

Custom backend control

Phase 2 ‚Äî Add NAS

Media storage

Redundancy

Backup vault

Phase 3 ‚Äî Custom Home Server

Compute workloads

Plex transcoding

Game servers

Docker orchestration

VM experimentation

Pi becomes:

Edge device

Testing server

Secondary node

Durable Constraints Identified

Self-hosted systems depend on home internet stability.

SD cards are failure points.

Consumer power grid reliability is a factor.

Pi is not designed for enterprise-grade uptime.

Prebuilt NAS units prioritize storage over compute.

Heavy workloads require CPU headroom beyond Pi/NAS-level chips.

Unresolved Items

Whether Plex will require transcoding or direct play only.

Expected storage growth (TB scale not defined).

Maximum concurrent users (media or game servers).

Whether long-term hosting will remain home-based or migrate to VPS.

Whether compute and storage will remain combined or be separated into:

Dedicated NAS

Dedicated compute server

Strategic Position

Current Pi setup is:

Technically valid

Architecturally correct

Suitable for early-stage production

Future scaling will require:

Either VPS migration

Or dedicated home server hardware

No architectural rebuild required ‚Äî only infrastructure scaling.

